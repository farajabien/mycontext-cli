import { Command } from "commander";
import chalk from "chalk";
import * as fs from "fs-extra";
import path from "path";
import { CONTEXT_FILES } from "../constants/fileNames";
import { EnhancedSpinner } from "../utils/spinner";
import { logger } from "../utils/logger";

interface DesignPromptOptions {
  output?: string;
  format?: "stitch" | "general" | "api";
  includeAll?: boolean;
}

export class GenerateDesignPromptCommand {
  private spinner: EnhancedSpinner;

  constructor() {
    this.spinner = new EnhancedSpinner("Generating design prompt...");
  }

  async execute(options: DesignPromptOptions): Promise<void> {
    const projectPath = process.cwd();
    const contextDir = path.join(projectPath, ".mycontext");

    this.spinner.start();

    // Check if .mycontext directory exists
    if (!fs.existsSync(contextDir)) {
      this.spinner.fail("No .mycontext directory found");
      console.log(
        chalk.red(
          "\nâŒ No .mycontext directory found. Run 'mycontext generate context' first."
        )
      );
      return;
    }

    // Load all context files
    const context = await this.loadContextFiles(contextDir);

    // Generate the design prompt
    const prompt = this.generateDesignPrompt(context, options.format || "general");

    // Determine output path
    const outputPath = options.output
      ? path.resolve(options.output)
      : path.join(contextDir, "design-prompt.txt");

    // Write the prompt
    await fs.writeFile(outputPath, prompt, "utf8");

    this.spinner.succeed("Design prompt generated");

    console.log(chalk.green(`\nâœ… Design prompt saved to: ${outputPath}`));
    console.log(
      chalk.blue(
        "\nðŸ’¡ Copy this prompt and paste it into your AI design tool (Stitch, etc.)"
      )
    );
    console.log(
      chalk.gray(
        `\nðŸ“‹ Prompt length: ${prompt.length} characters (${Math.ceil(prompt.length / 1000)}k)`
      )
    );

    // Also output to console if requested
    if (options.format === "api") {
      console.log(chalk.yellow("\nðŸ“¡ API JSON format:"));
      console.log(
        JSON.stringify(
          {
            prompt,
            metadata: {
              generatedAt: new Date().toISOString(),
              format: options.format,
              contextFiles: Object.keys(context).filter(
                (key) => context[key as keyof typeof context]
              ),
            },
          },
          null,
          2
        )
      );
    }
  }

  private async loadContextFiles(
    contextDir: string
  ): Promise<Record<string, string>> {
    const context: Record<string, string> = {};

    const files = [
      { key: "prd", file: CONTEXT_FILES.PRD },
      { key: "features", file: CONTEXT_FILES.FEATURES },
      { key: "userFlows", file: CONTEXT_FILES.USER_FLOWS },
      { key: "edgeCases", file: CONTEXT_FILES.EDGE_CASES },
      { key: "technicalSpecs", file: CONTEXT_FILES.TECHNICAL_SPECS },
      { key: "branding", file: CONTEXT_FILES.BRANDING },
      { key: "projectStructure", file: CONTEXT_FILES.PROJECT_STRUCTURE },
    ];

    for (const { key, file } of files) {
      const filePath = path.join(contextDir, file);
      if (fs.existsSync(filePath)) {
        try {
          const content = fs.readFileSync(filePath, "utf8");
          // Clean up markdown headers and metadata for cleaner prompt
          const cleaned = this.cleanContent(content);
          if (cleaned.trim()) {
            context[key] = cleaned;
          }
        } catch (error) {
          logger.warn(`Could not load ${file}`);
        }
      }
    }

    // Load component list if exists
    const componentListPath = path.join(
      contextDir,
      CONTEXT_FILES.COMPONENT_LIST
    );
    if (fs.existsSync(componentListPath)) {
      try {
        const componentList = JSON.parse(
          fs.readFileSync(componentListPath, "utf8")
        );
        context.componentList = JSON.stringify(componentList, null, 2);
      } catch (error) {
        logger.warn("Could not load component list");
      }
    }

    return context;
  }

  private cleanContent(content: string): string {
    // Remove metadata footers
    return content
      .replace(/---\s*\n[\s\S]*?Generated by:.*?\n[\s\S]*?---/g, "")
      .replace(/\*\*Generated\*\*:.*?\n/g, "")
      .replace(/\*\*Source Context Files\*\*:.*?\n/g, "")
      .replace(/## Document Information[\s\S]*?$/g, "")
      .replace(/## Context File References[\s\S]*?$/g, "")
      .trim();
  }

  private generateDesignPrompt(
    context: Record<string, string>,
    format: "stitch" | "general" | "api"
  ): string {
    const sections: string[] = [];

    // Header
    sections.push("# App Design Context");
    sections.push(
      "This document contains all the context needed to design beautiful, production-ready UI screens for this application."
    );
    sections.push("");

    // PRD Section (most important)
    if (context.prd) {
      sections.push("## Product Requirements Document (PRD)");
      sections.push(context.prd);
      sections.push("");
    }

    // Features Section
    if (context.features) {
      sections.push("## Features & User Actions");
      sections.push(context.features);
      sections.push("");
    }

    // User Flows Section
    if (context.userFlows) {
      sections.push("## User Flows");
      sections.push(context.userFlows);
      sections.push("");
    }

    // Branding Section (critical for design)
    if (context.branding) {
      sections.push("## Brand Guidelines & Design System");
      sections.push(context.branding);
      sections.push("");
    }

    // Technical Specs (for understanding constraints)
    if (context.technicalSpecs) {
      sections.push("## Technical Specifications");
      sections.push(context.technicalSpecs);
      sections.push("");
    }

    // Edge Cases (for comprehensive design)
    if (context.edgeCases) {
      sections.push("## Edge Cases & Error States");
      sections.push(context.edgeCases);
      sections.push("");
    }

    // Component List (if exists)
    if (context.componentList) {
      sections.push("## Required Components");
      sections.push(
        "The following components should be included in the design:"
      );
      sections.push("```json");
      sections.push(context.componentList);
      sections.push("```");
      sections.push("");
    }

    // Project Structure (for context)
    if (context.projectStructure) {
      sections.push("## Project Structure");
      sections.push(context.projectStructure);
      sections.push("");
    }

    // Format-specific instructions
    if (format === "stitch") {
      sections.push("---");
      sections.push("");
      sections.push("## Design Instructions for Stitch");
      sections.push("");
      sections.push(
        "Please create beautiful, modern UI designs for this application based on the context above."
      );
      sections.push("");
      sections.push("Design Requirements:");
      sections.push(
        "- Follow the brand guidelines and design system specified above"
      );
      sections.push(
        "- Create designs for all user flows and features mentioned"
      );
      sections.push(
        "- Include all required components from the component list"
      );
      sections.push(
        "- Consider edge cases and error states in your designs"
      );
      sections.push(
        "- Ensure designs are mobile-first and responsive"
      );
      sections.push(
        "- Use modern UI/UX best practices and accessibility standards"
      );
    } else if (format === "general") {
      sections.push("---");
      sections.push("");
      sections.push(
        "Use this context to design beautiful UI screens for this application."
      );
      sections.push(
        "Focus on the user flows, features, and brand guidelines provided above."
      );
    }

    return sections.join("\n");
  }
}

export function registerGenerateDesignPromptCommand(program: Command): void {
  program
    .command("generate:design-prompt")
    .alias("gdp")
    .description(
      "Generate a design prompt optimized for AI design tools (Stitch, etc.)"
    )
    .option(
      "-o, --output <path>",
      "Output file path (default: .mycontext/design-prompt.txt)"
    )
    .option(
      "-f, --format <format>",
      "Output format: stitch, general, or api (default: general)"
    )
    .action(async (options: DesignPromptOptions) => {
      const command = new GenerateDesignPromptCommand();
      await command.execute(options);
    });
}