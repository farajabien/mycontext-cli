import chalk from "chalk";
import prompts from "prompts";
import * as fs from "fs-extra";
import path from "path";
import { CommandOptions } from "../types";
import { FileSystemManager } from "../utils/fileSystem";
import {
  ContextValidator,
  AutoGeneratedFeature,
  ContextGap,
} from "../services/ContextValidator";

export interface ReviewContextOptions extends CommandOptions {
  autoApprove?: boolean;
  skipGaps?: boolean;
}

export class ReviewContextCommand {
  private fs = new FileSystemManager();
  private contextValidator = new ContextValidator();

  async execute(options: ReviewContextOptions): Promise<void> {
    console.log(
      chalk.blue("üîç Reviewing context files and auto-generated features...")
    );

    try {
      const contextDir = ".mycontext";

      // Check if auto-generated.json exists
      const autoGeneratedPath = path.join(contextDir, "auto-generated.json");
      if (!(await this.fs.exists(autoGeneratedPath))) {
        console.log(
          chalk.yellow(
            "‚ö†Ô∏è  No auto-generated features found. Run 'mycontext generate:context' first."
          )
        );
        return;
      }

      // Load auto-generated data
      const autoGeneratedData = JSON.parse(
        await this.fs.readFile(autoGeneratedPath)
      );
      const { features, gaps } = autoGeneratedData;

      if (features.length === 0 && gaps.length === 0) {
        console.log(chalk.green("‚úÖ No features or gaps to review."));
        return;
      }

      // Review critical gaps first
      if (!options.skipGaps && gaps.length > 0) {
        await this.reviewGaps(gaps, options);
      }

      // Review auto-generated features
      if (features.length > 0) {
        await this.reviewFeatures(features, options);
      }

      // Save approvals
      await this.saveApprovals(contextDir, features, gaps);

      console.log(chalk.green("‚úÖ Context review completed!"));
    } catch (error) {
      console.error(chalk.red("‚ùå Context review failed:"), error);
      throw error;
    }
  }

  /**
   * Review critical gaps and get user input
   */
  private async reviewGaps(
    gaps: ContextGap[],
    options: ReviewContextOptions
  ): Promise<void> {
    const criticalGaps = gaps.filter((gap) => gap.category === "critical");
    const importantGaps = gaps.filter((gap) => gap.category === "important");
    const optionalGaps = gaps.filter((gap) => gap.category === "optional");

    if (criticalGaps.length > 0) {
      console.log(chalk.red("\n‚ùå Critical information missing:"));
      await this.handleGaps(criticalGaps, "critical", options);
    }

    if (importantGaps.length > 0) {
      console.log(chalk.yellow("\n‚ö†Ô∏è  Important information missing:"));
      await this.handleGaps(importantGaps, "important", options);
    }

    if (optionalGaps.length > 0) {
      console.log(chalk.blue("\nüí° Optional improvements:"));
      await this.handleGaps(optionalGaps, "optional", options);
    }
  }

  /**
   * Handle gaps of a specific category
   */
  private async handleGaps(
    gaps: ContextGap[],
    category: string,
    options: ReviewContextOptions
  ): Promise<void> {
    for (const gap of gaps) {
      console.log(chalk.yellow(`\n${gap.question}`));
      console.log(chalk.gray(`   ${gap.reasoning}`));

      if (gap.suggestedAnswers && gap.suggestedAnswers.length > 0) {
        const response = await prompts({
          type: "select",
          name: "answer",
          message: "Choose an answer:",
          choices: gap.suggestedAnswers.map((answer, index) => ({
            title: answer,
            value: answer,
            description: `Option ${String.fromCharCode(97 + index)}`,
          })),
          initial: 0,
        });

        if (response.answer) {
          // Store the answer for later use
          gap.userAnswer = response.answer;
        }
      } else {
        const response = await prompts({
          type: "text",
          name: "answer",
          message: "Please provide the missing information:",
          validate: (value: string) =>
            value.length > 0 ? true : "Please provide an answer",
        });

        if (response.answer) {
          gap.userAnswer = response.answer;
        }
      }
    }
  }

  /**
   * Review auto-generated features
   */
  private async reviewFeatures(
    features: AutoGeneratedFeature[],
    options: ReviewContextOptions
  ): Promise<void> {
    console.log(chalk.yellow("\nüìã Auto-generated Features Review"));
    console.log(
      chalk.gray("Review each feature and decide whether to keep it:")
    );

    for (const feature of features) {
      console.log(chalk.blue(`\n${feature.feature}`));
      console.log(chalk.gray(`   Reasoning: ${feature.reasoning}`));
      console.log(chalk.gray(`   Confidence: ${feature.confidence}`));
      console.log(chalk.gray(`   Source: ${feature.contextSource}`));

      if (options.autoApprove) {
        feature.approved = true;
        console.log(chalk.green("   ‚úÖ Auto-approved"));
        continue;
      }

      const response = await prompts({
        type: "select",
        name: "action",
        message: "What would you like to do?",
        choices: [
          {
            title: "Accept",
            value: "accept",
            description: "Keep this feature",
          },
          {
            title: "Reject",
            value: "reject",
            description: "Remove this feature",
          },
          { title: "Edit", value: "edit", description: "Modify this feature" },
          { title: "Skip", value: "skip", description: "Decide later" },
        ],
        initial: 0,
      });

      switch (response.action) {
        case "accept":
          feature.approved = true;
          feature.modified = false;
          console.log(chalk.green("   ‚úÖ Accepted"));
          break;
        case "reject":
          feature.approved = false;
          feature.modified = false;
          console.log(chalk.red("   ‚ùå Rejected"));
          break;
        case "edit":
          await this.editFeature(feature);
          break;
        case "skip":
          feature.approved = null;
          console.log(chalk.yellow("   ‚è≠Ô∏è  Skipped"));
          break;
      }
    }
  }

  /**
   * Edit a feature
   */
  private async editFeature(feature: AutoGeneratedFeature): Promise<void> {
    const response = await prompts({
      type: "text",
      name: "editedFeature",
      message: "Edit the feature description:",
      initial: feature.feature,
      validate: (value: string) =>
        value.length > 0 ? true : "Please provide a description",
    });

    if (response.editedFeature) {
      feature.feature = response.editedFeature;
      feature.approved = true;
      feature.modified = true;
      console.log(chalk.green("   ‚úèÔ∏è  Feature updated"));
    }
  }

  /**
   * Save approvals to file
   */
  private async saveApprovals(
    contextDir: string,
    features: AutoGeneratedFeature[],
    gaps: ContextGap[]
  ): Promise<void> {
    const approvalsData = {
      features: features.reduce((acc, feature) => {
        acc[feature.id] = {
          approved: feature.approved,
          modified: feature.modified || false,
          feature: feature.feature,
          reasoning: feature.reasoning,
        };
        return acc;
      }, {} as Record<string, any>),
      gaps_addressed: gaps.reduce((acc, gap) => {
        if (gap.userAnswer) {
          acc[gap.id] = gap.userAnswer;
        }
        return acc;
      }, {} as Record<string, string>),
      timestamp: new Date().toISOString(),
      version: "1.0",
    };

    await this.fs.writeFile(
      path.join(contextDir, "approvals.json"),
      JSON.stringify(approvalsData, null, 2)
    );

    // Update PRD with gap answers
    await this.updatePRDWithAnswers(contextDir, gaps);

    console.log(
      chalk.green("   üíæ Approvals saved to .mycontext/approvals.json")
    );
  }

  /**
   * Update PRD with gap answers
   */
  private async updatePRDWithAnswers(
    contextDir: string,
    gaps: ContextGap[]
  ): Promise<void> {
    const prdPath = path.join(contextDir, "01-prd.md");

    if (!(await this.fs.exists(prdPath))) {
      return; // No PRD to update
    }

    let prdContent = await this.fs.readFile(prdPath);
    let hasUpdates = false;

    for (const gap of gaps) {
      if (gap.userAnswer) {
        // Add answer to appropriate section based on gap ID
        if (gap.id === "game-type") {
          prdContent = this.updatePRDSection(
            prdContent,
            "## Game Mechanics",
            `- **Game Type**: ${gap.userAnswer}\n`
          );
          hasUpdates = true;
        } else if (gap.id === "game-rules") {
          prdContent = this.updatePRDSection(
            prdContent,
            "## Game Mechanics",
            `- **Core Rules**: ${gap.userAnswer}\n`
          );
          hasUpdates = true;
        } else if (gap.id === "auth-method") {
          prdContent = this.updatePRDSection(
            prdContent,
            "## Technical Requirements",
            `- **Authentication**: ${gap.userAnswer}\n`
          );
          hasUpdates = true;
        }
      }
    }

    if (hasUpdates) {
      await this.fs.writeFile(prdPath, prdContent);
      console.log(chalk.green("   üìù PRD updated with gap answers"));
    }
  }

  /**
   * Update a section in PRD content
   */
  private updatePRDSection(
    content: string,
    sectionHeader: string,
    newContent: string
  ): string {
    const lines = content.split("\n");
    const sectionIndex = lines.findIndex(
      (line) => line.trim() === sectionHeader
    );

    if (sectionIndex === -1) {
      // Section doesn't exist, add it at the end
      return content + `\n\n${sectionHeader}\n${newContent}`;
    }

    // Find the end of the section (next ## or end of file)
    let endIndex = sectionIndex + 1;
    while (endIndex < lines.length && !lines[endIndex]?.startsWith("##")) {
      endIndex++;
    }

    // Insert the new content before the end of the section
    lines.splice(endIndex, 0, newContent);
    return lines.join("\n");
  }

  /**
   * Get approval status for a feature
   */
  static async getFeatureApproval(featureId: string): Promise<boolean | null> {
    try {
      const approvalsPath = ".mycontext/approvals.json";
      if (!(await fs.pathExists(approvalsPath))) {
        return null;
      }

      const approvalsData = JSON.parse(
        await fs.readFile(approvalsPath, "utf8")
      );
      const feature = approvalsData.features[featureId];

      return feature ? feature.approved : null;
    } catch (error) {
      return null;
    }
  }

  /**
   * Check if all critical gaps are addressed
   */
  static async areCriticalGapsAddressed(): Promise<boolean> {
    try {
      const autoGeneratedPath = ".mycontext/auto-generated.json";
      const approvalsPath = ".mycontext/approvals.json";

      if (
        !(await fs.pathExists(autoGeneratedPath)) ||
        !(await fs.pathExists(approvalsPath))
      ) {
        return false;
      }

      const autoGeneratedData = JSON.parse(
        await fs.readFile(autoGeneratedPath, "utf8")
      );
      const approvalsData = JSON.parse(
        await fs.readFile(approvalsPath, "utf8")
      );

      const criticalGaps = autoGeneratedData.gaps.filter(
        (gap: ContextGap) => gap.category === "critical"
      );

      return criticalGaps.every(
        (gap: ContextGap) => approvalsData.gaps_addressed[gap.id]
      );
    } catch (error) {
      return false;
    }
  }
}
