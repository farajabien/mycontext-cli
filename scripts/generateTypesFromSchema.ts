#!/usr/bin/env tsx

/**
 * Generate TypeScript types from InstantDB schema
 *
 * Reads .mycontext/schema.ts and generates .mycontext/types.ts with:
 * - Entity types from schema
 * - Component prop types based on schema fields
 * - Dummy data generators from schema structure
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface SchemaEntity {
  [fieldName: string]: {
    type: string;
    optional?: boolean;
    indexed?: boolean;
  };
}

interface InstantDBSchema {
  entities: {
    [entityName: string]: SchemaEntity;
  };
  links?: {
    [linkName: string]: {
      forward: {
        on: string;
        has: "one" | "many";
        label: string;
      };
      reverse: {
        on: string;
        has: "one" | "many";
        label: string;
      };
    };
  };
}

class SchemaTypesGenerator {
  private schemaPath: string;
  private typesPath: string;

  constructor(
    schemaPath: string = ".mycontext/schema.ts",
    typesPath: string = ".mycontext/types.ts"
  ) {
    this.schemaPath = schemaPath;
    this.typesPath = typesPath;
  }

  async generateTypes(): Promise<void> {
    console.log("🔄 Generating types from InstantDB schema...");

    // Check if schema file exists
    if (!fs.existsSync(this.schemaPath)) {
      throw new Error(`Schema file not found: ${this.schemaPath}`);
    }

    // Read and parse schema
    const schemaContent = fs.readFileSync(this.schemaPath, "utf8");
    const schema = this.extractSchemaFromContent(schemaContent);

    if (!schema) {
      throw new Error("Could not extract schema from file");
    }

    // Generate types
    const typesContent = this.generateTypesContent(schema);

    // Write types file
    fs.writeFileSync(this.typesPath, typesContent);

    console.log(`✅ Types generated successfully: ${this.typesPath}`);
    console.log(
      `📊 Generated types for ${Object.keys(schema.entities).length} entities`
    );
  }

  private extractSchemaFromContent(content: string): InstantDBSchema | null {
    try {
      // Extract schema object from TypeScript file
      const schemaMatch = content.match(
        /export\s+const\s+schema\s*=\s*({[\s\S]*?});/
      );
      if (!schemaMatch) {
        console.warn("Could not find schema export in file");
        return null;
      }

      // Convert to valid JSON by handling TypeScript syntax
      let schemaJson = schemaMatch[1]
        .replace(/(\w+):/g, '"$1":') // Add quotes to keys
        .replace(/'/g, '"') // Replace single quotes with double quotes
        .replace(/,\s*}/g, "}") // Remove trailing commas
        .replace(/,\s*]/g, "]"); // Remove trailing commas in arrays

      return JSON.parse(schemaJson);
    } catch (error) {
      console.error("Error parsing schema:", error);
      return null;
    }
  }

  private generateTypesContent(schema: InstantDBSchema): string {
    const entityTypes = this.generateEntityTypes(schema.entities);
    const componentTypes = this.generateComponentTypes(schema.entities);
    const dummyDataGenerators = this.generateDummyDataGenerators(
      schema.entities
    );
    const linkTypes = this.generateLinkTypes(schema.links || {});

    return `/**
 * Generated TypeScript types from InstantDB schema
 * 
 * This file is automatically generated from .mycontext/schema.ts
 * Do not edit manually - regenerate with: mycontext generate:types --from-schema
 */

// ============================================================================
// ENTITY TYPES
// ============================================================================

${entityTypes}

// ============================================================================
// COMPONENT PROP TYPES
// ============================================================================

${componentTypes}

// ============================================================================
// LINK TYPES
// ============================================================================

${linkTypes}

// ============================================================================
// DUMMY DATA GENERATORS
// ============================================================================

${dummyDataGenerators}

// ============================================================================
// UTILITY TYPES
// ============================================================================

export type EntityName = keyof typeof schema.entities;
export type EntityType<T extends EntityName> = typeof schema.entities[T];

// Helper type for component props that use entities
export type ComponentProps<T extends EntityName> = {
  [K in T]: EntityType<T>;
} & {
  variant?: "mobile" | "desktop";
  className?: string;
};

// Export schema for reference
export { schema } from "./schema";
`;
  }

  private generateEntityTypes(entities: {
    [entityName: string]: SchemaEntity;
  }): string {
    const entityTypeDefinitions = Object.entries(entities).map(
      ([entityName, fields]) => {
        const fieldTypes = Object.entries(fields)
          .map(([fieldName, fieldDef]) => {
            const tsType = this.mapSchemaTypeToTS(fieldDef.type);
            const optional = fieldDef.optional ? "?" : "";
            return `  ${fieldName}${optional}: ${tsType};`;
          })
          .join("\n");

        return `export interface ${this.toPascalCase(entityName)} {
${fieldTypes}
}`;
      }
    );

    return entityTypeDefinitions.join("\n\n");
  }

  private generateComponentTypes(entities: {
    [entityName: string]: SchemaEntity;
  }): string {
    const componentTypes = Object.keys(entities).map((entityName) => {
      const pascalName = this.toPascalCase(entityName);
      const componentName = `${pascalName}Card`;
      const listName = `${pascalName}List`;
      const formName = `${pascalName}Form`;

      return `// ${pascalName} component prop types
export interface ${componentName}Props {
  ${entityName}: ${pascalName};
  variant?: "mobile" | "desktop";
  className?: string;
  onEdit?: (${entityName}: ${pascalName}) => void;
  onDelete?: (${entityName}: ${pascalName}) => void;
}

export interface ${listName}Props {
  ${entityName}s: ${pascalName}[];
  variant?: "mobile" | "desktop";
  className?: string;
  onSelect?: (${entityName}: ${pascalName}) => void;
}

export interface ${formName}Props {
  ${entityName}?: ${pascalName};
  variant?: "mobile" | "desktop";
  className?: string;
  onSubmit: (${entityName}: ${pascalName}) => void;
  onCancel?: () => void;
}`;
    });

    return componentTypes.join("\n\n");
  }

  private generateLinkTypes(links: { [linkName: string]: any }): string {
    if (Object.keys(links).length === 0) {
      return "// No links defined in schema";
    }

    const linkTypes = Object.entries(links).map(([linkName, linkDef]) => {
      const forwardEntity = this.toPascalCase(linkDef.forward.on);
      const reverseEntity = this.toPascalCase(linkDef.reverse.on);

      return `export interface ${this.toPascalCase(linkName)}Link {
  ${linkDef.forward.label}: ${
        linkDef.forward.has === "one" ? forwardEntity : `${forwardEntity}[]`
      };
  ${linkDef.reverse.label}: ${
        linkDef.reverse.has === "one" ? reverseEntity : `${reverseEntity}[]`
      };
}`;
    });

    return linkTypes.join("\n\n");
  }

  private generateDummyDataGenerators(entities: {
    [entityName: string]: SchemaEntity;
  }): string {
    const generators = Object.entries(entities).map(([entityName, fields]) => {
      const pascalName = this.toPascalCase(entityName);

      const fieldGenerators = Object.entries(fields)
        .map(([fieldName, fieldDef]) => {
          return `    ${fieldName}: ${this.generateDummyValue(
            fieldName,
            fieldDef.type
          )},`;
        })
        .join("\n");

      return `export function generateDummy${pascalName}(): ${pascalName} {
  return {
${fieldGenerators}
  };
}

export function generateDummy${pascalName}List(count: number = 5): ${pascalName}[] {
  return Array.from({ length: count }, () => generateDummy${pascalName}());
}`;
    });

    return generators.join("\n\n");
  }

  private generateDummyValue(fieldName: string, fieldType: string): string {
    const lowerFieldName = fieldName.toLowerCase();

    // Generate realistic dummy data based on field name and type
    if (lowerFieldName.includes("id")) {
      return `"${this.generateId()}"`;
    } else if (lowerFieldName.includes("name")) {
      return `"${this.generateName()}"`;
    } else if (lowerFieldName.includes("email")) {
      return `"${this.generateEmail()}"`;
    } else if (
      lowerFieldName.includes("url") ||
      lowerFieldName.includes("avatar") ||
      lowerFieldName.includes("image")
    ) {
      return `"${this.generateImageUrl()}"`;
    } else if (
      lowerFieldName.includes("description") ||
      lowerFieldName.includes("bio")
    ) {
      return `"${this.generateDescription()}"`;
    } else if (
      lowerFieldName.includes("date") ||
      lowerFieldName.includes("time")
    ) {
      return `"${this.generateDate()}"`;
    } else if (
      lowerFieldName.includes("price") ||
      lowerFieldName.includes("amount") ||
      lowerFieldName.includes("cost")
    ) {
      return this.generateNumber(1, 1000);
    } else if (
      lowerFieldName.includes("count") ||
      lowerFieldName.includes("quantity")
    ) {
      return this.generateNumber(1, 100);
    } else if (
      lowerFieldName.includes("active") ||
      lowerFieldName.includes("enabled") ||
      lowerFieldName.includes("published")
    ) {
      return "true";
    } else {
      // Default based on type
      switch (fieldType) {
        case "string":
          return `"Sample ${fieldName}"`;
        case "number":
          return this.generateNumber(1, 100);
        case "boolean":
          return "true";
        case "date":
          return `"${this.generateDate()}"`;
        default:
          return `"Sample ${fieldName}"`;
      }
    }
  }

  private mapSchemaTypeToTS(schemaType: string): string {
    switch (schemaType) {
      case "string":
        return "string";
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "date":
        return "string"; // InstantDB dates are strings
      case "json":
        return "any";
      default:
        return "string";
    }
  }

  private toPascalCase(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }

  private generateName(): string {
    const names = [
      "John Doe",
      "Jane Smith",
      "Bob Johnson",
      "Alice Brown",
      "Charlie Wilson",
    ];
    return names[Math.floor(Math.random() * names.length)];
  }

  private generateEmail(): string {
    const domains = ["example.com", "test.com", "demo.org"];
    const name = this.generateName().toLowerCase().replace(" ", ".");
    const domain = domains[Math.floor(Math.random() * domains.length)];
    return `${name}@${domain}`;
  }

  private generateImageUrl(): string {
    const images = [
      "https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=150&h=150&fit=crop&crop=face",
      "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=150&h=150&fit=crop&crop=face",
      "https://images.unsplash.com/photo-1494790108755-2616b612b786?w=150&h=150&fit=crop&crop=face",
    ];
    return images[Math.floor(Math.random() * images.length)];
  }

  private generateDescription(): string {
    const descriptions = [
      "This is a sample description for testing purposes.",
      "A brief description of the item or entity.",
      "Sample content that demonstrates the field usage.",
    ];
    return descriptions[Math.floor(Math.random() * descriptions.length)];
  }

  private generateDate(): string {
    const now = new Date();
    const randomDays = Math.floor(Math.random() * 365);
    const date = new Date(now.getTime() - randomDays * 24 * 60 * 60 * 1000);
    return date.toISOString();
  }

  private generateNumber(min: number, max: number): string {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
}

// CLI execution
async function main() {
  const args = process.argv.slice(2);
  const schemaPath = args[0] || ".mycontext/schema.ts";
  const typesPath = args[1] || ".mycontext/types.ts";

  try {
    const generator = new SchemaTypesGenerator(schemaPath, typesPath);
    await generator.generateTypes();
  } catch (error) {
    console.error("❌ Error generating types:", error);
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
